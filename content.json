{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2023-09-08T09:17:36.750Z","updated":"2023-09-08T06:44:12.978Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-09-08T09:08:06.956Z","updated":"2023-09-08T06:44:12.978Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2023-09-08T07:23:17.952Z","updated":"2023-09-08T06:44:12.978Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-09-12T09:33:57.658Z","updated":"2023-09-08T06:44:12.979Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-12T09:34:32.613Z","updated":"2023-09-12T09:34:32.613Z","comments":false,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-12T09:34:52.260Z","updated":"2023-09-08T06:44:12.979Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-09-12T09:33:50.675Z","updated":"2023-09-12T09:33:50.575Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"读文章","slug":"读文章","date":"2023-09-26T03:47:00.000Z","updated":"2023-09-26T03:55:55.880Z","comments":false,"path":"2023/09/26/读文章/","link":"","permalink":"http://example.com/2023/09/26/%E8%AF%BB%E6%96%87%E7%AB%A0/","excerpt":"","text":"对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI 十人谈原创 何思思 AI科技评论 2023-09-22 10:40 发表于广东 https://mp.weixin.qq.com/s/0xt-EcuKYo7ceU4tBm3EDg 澜码科技于今年2月份在上海成立，与其他创业公司不同的是，澜码科技想做的是基于大模型打造新一代的自动化平台。 虽然成立时间不长，但澜码科技已于近期完成了数千万人民币的A轮融资，其中IDG资本、联新资本、Atom Capital三家参与了本次投资。 另外在产品层面，澜码科技已经成功研发出了Agent平台Ask XBot。AI科技评论了解到，其操作主要分为两层，第一层由专家通过传统、新兴的对话交互的方式定义工作流程；第二层由一线员工通过自然语言指令，控制机器协助完成数据分析、资料调取等工作。 AI科技评论：选择基于大模型做新一代的自动化平台，是受哪段经历的启发？ 周健：主要是做RPA给我带来的新视角，现在我做得是人和系统的连接，这样我就能把重复性的劳动问题解决。但不同的是，RPA替代的是一线业务人员重复性的工作，解决的是工作效率问题，我们今天在大语言模型下提供专家知识和经验，解决的是业务流程的质量问题。 其实我做RPA时，就看到了很多自动化的场景，我知道财务有什么场景，HR有什么场景，国家电网有什么场景，银行有什么场景，保险有什么场景，但由于AI 1.0阶段的AI技术不成熟，成本也非常高，所以很难实现。 RPA？ AI科技评论：澜码现在主要服务哪些客户群体？ 周健：猎头招聘是主攻场景之一。初级猎头搜候选人主要通过猎聘、脉脉、BOSS直聘等，有3、4年工作经验的猎头可能不需要了，因为他们都会有一个候选人私域库，大概2000人左右，这2000人平均每两、三年要换一次工作，这部分信息的更新是一个很大体量的工作。 此外，猎头顾问基于私域库寻找候选人的工作方式，对顾问来说准确率高，工作量也小，但是很难把打电话沟通或见面沟通时有价值的数据补充到私域库中，只能在私域库自己去打标签，比如今天和候选人打电话说了啥，当时自己记下来了，但时间一长就忘了，私域库的管理效率和质量都不高。 大模型出来后，腾讯会议之类的软件有了语音识别的功能，就可以把打电话沟通等交互过程中的“活”数据整理、提炼、存档，这些都是大模型赋予的能力。 大模型催生了第四个新的范式，可以叫对话式或者匹配式。现在的猎头工作是人岗匹配，抽象来说就是一个X space，x空间和y空间。x空间描述需求，y空间匹配需求。 大模型出来之后，对话的方式可以提高匹配效率，这是很典型的场景，也在更多其他场景适用，比如房产中介搜房源，设计师搜图，外包程序员搜函数、代码等。 AI科技评论：国内外的大模型，都有用过吗？ 周健：没必要把所有的大模型都用一遍，只需要用目前水平最高的模型就够了。所以我们是在用GPT 4做训练。比如我有10个问题，我会让GPT 4 帮我破解这10个问题，破解完我再让 GPT 4 帮我确认答案、评价答案，然后训练出一个小模型，解决场景问题。","categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Python 装饰器","slug":"Python-装饰器","date":"2023-09-26T01:28:51.000Z","updated":"2023-09-26T03:07:17.422Z","comments":false,"path":"2023/09/26/Python-装饰器/","link":"","permalink":"http://example.com/2023/09/26/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"Python 函数装饰器 - 菜鸟教程https://www.runoob.com/w3cnote/python-func-decorators.html 参考：https://eastlakeside.gitbook.io/interpy-zh/decorators/（与本文完全一致） 一切皆对象在函数中定义函数从函数中返回函数将函数作为参数传给另一个函数你的第一个装饰器装饰器让你在一个函数的前后去执行代码。 装饰器封装一个函数，并且用这样或者那样的方式来修改它的行为。 @ 符号？那只是一个简短的方式来生成一个被装饰的函数。 使用functools.wraps还原被重写了被装饰函数的名字和注释文档(docstring) from functools import wraps @wraps(a_func) @wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。 使用场景授权(Authorization)装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。 日志(Logging)带参数的装饰器在函数中嵌入装饰器装饰器类装饰器 - 廖雪峰https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584 现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下： 12345def log(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper log()是一个decorator，接受一个函数作为参数，并返回一个函数。 decorator用法： 123@logdef now(): print(&#x27;2015-3-25&#x27;) 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： 1234567def log(text): def decorator(func): def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下： 123@log(&#x27;execute&#x27;)def now(): print(&#x27;2015-3-25&#x27;) __name__属性变化 12345678import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 或者针对带参数的decorator： 12345678910import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator lru_cache 装饰器https://juejin.cn/post/6939345971042058248 这里的lru_cache是什么意思和作用？*args为什么带星号 12345678@lru_cache(maxsize=128)def get_conf(*args): # 建议您复制一个config_private.py放自己的秘密, 如API和代理网址, 避免不小心传github被别人看到 res = [] for arg in args: r = read_single_conf_with_lru_cache(arg) res.append(r) return res lru_cache是Python标准库中的一个装饰器，用于实现缓存功能。它可以缓存函数的返回值，以便在后续的调用中避免重新计算相同的输入值所对应的结果。这有助于提高函数的执行效率，特别是在需要计算代价较高的操作时。 具体来说： lru_cache是Least Recently Used（LRU，最近最少使用）缓存的缩写，它会保留最近调用的函数的结果，并在缓存达到指定大小（由maxsize参数指定）时，自动淘汰最不常使用的结果，以保持缓存的大小。 maxsize参数指定缓存的最大大小，即最多保存多少个不同输入值的结果。如果没有指定maxsize，则缓存的大小会无限增长。 当函数被装饰为@lru_cache(maxsize=128)时，函数的每个不同的参数组合（传递给*args的值）都会被缓存，以及它们对应的返回值。下次再次使用相同的参数调用函数时，如果参数组合已经在缓存中，函数不会再次执行，而是直接返回之前的结果。 这里的*args是Python中的可变参数，它允许函数接受任意数量的位置参数。在get_conf函数中，*args表示接受任意数量的参数，这些参数将被传递到read_single_conf_with_lru_cache函数中。*用于解包参数，因为args是一个元组，*args会将元组中的每个元素作为单独的参数传递给函数。 总结：@lru_cache用于缓存函数的计算结果，*args用于接受任意数量的输入参数，并将它们传递给被装饰的函数。这可以提高函数的执行效率，特别是在需要多次调用相同参数的情况下。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Github+Hexo搭建个人博客","slug":"Github+Hexo搭建个人博客","date":"2023-09-25T09:46:34.000Z","updated":"2023-09-26T01:48:01.351Z","comments":false,"path":"2023/09/25/Github+Hexo搭建个人博客/","link":"","permalink":"http://example.com/2023/09/25/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"HexoHexo 是一个基于 Node.js 的静态网站生成器，它帮助用户快速构建和部署博客和其他类型的静态网站。Hexo 的主要特点包括简单易用、高度可配置、支持主题和插件，以及快速的构建和部署过程。下面是一些关于 Hexo 的基本信息和用法： 主要功能和特点： Markdown 支持： Hexo 使用 Markdown 作为默认的内容格式，这使得撰写和发布文章变得非常简单。 快速构建： Hexo生成静态网页，所以页面加载速度很快，因为不需要在每个页面访问时进行数据库查询。 主题支持： Hexo支持自定义主题，用户可以选择或创建适合自己的主题来美化网站。 插件扩展： Hexo提供了许多插件，可以用来扩展其功能，如添加社交分享按钮、SEO优化、代码高亮等。 部署选项： Hexo支持多种部署选项，包括部署到GitHub Pages、Netlify、Vercel、FTP服务器等。 基本用法： 安装 Hexo： 首先，您需要在计算机上安装 Node.js 和 Git。然后使用以下命令安装 Hexo： 12bashCopy codenpm install -g hexo-cli 初始化博客： 使用以下命令在您的计算机上创建一个新的Hexo博客： 123bashCopy codehexo init myblogcd myblog 撰写文章： 使用Markdown格式编写文章，可以使用Hexo提供的命令来创建新文章： 12bashCopy codehexo new &quot;My New Post&quot; 这将在source/_posts目录下创建一个Markdown文件，您可以在其中编写文章内容。 生成静态文件： 使用以下命令生成静态文件： 12bashCopy codehexo generate (或简写为 hexo g) 这将生成静态网页到public文件夹中。 本地预览： 使用以下命令在本地预览您的网站： 12bashCopy codehexo server (或简写为 hexo s) 您可以在浏览器中访问http://localhost:4000来查看您的博客。 部署博客： 最后，您可以使用Hexo的部署命令将博客发布到您选择的托管平台或服务器上。根据您的部署选择，命令会有所不同。 一些也用Hexo搭建的个人博客网站https://hwame.top/categories/Hexo/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Git相关操作","slug":"Git相关操作","date":"2023-09-11T08:58:15.000Z","updated":"2023-09-26T01:48:14.040Z","comments":false,"path":"2023/09/11/Git相关操作/","link":"","permalink":"http://example.com/2023/09/11/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git配置（git config）Git 提供了一个叫做git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。 这些变量可以存放在以下三个不同的地方： · /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 · ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。 · 工作目录中的 .git/config 文件（当前项目的 Git 目录中的配置文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git&#x2F;config 里的配置会覆盖 &#x2F;etc&#x2F;gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 Git基础操作步骤1、 找一个自己想放东西的目录，作为仓库。初始化： 1git init 2、 配置个人信息 12git config --global user.name &quot;liuliuliu&quot;git config --global user.email [123456789@qq.com] 2-1、查看user信息 1git config --global -l 12user.name=liuliuliu``user.email=123456789@qq.com 2-2、查看某个环境变量的设定 12git config user.namegit config user.email 2-3、查看所有配置 1git config --list 2-4、删除 12git config --global --unset user.namegit config --global --unset user.email 3、 查看隐藏的.git目录 1ls -ah 4、 查看当前仓库状态，有没有什么是改动的、改动未提交的、全部提交 1git status 5、 查看文件的改动情况 1git diff 6、 查看历史记录 12git loggit log --pretty=oneline(显示成一行) 7、 回退到上一个提交的版本，HEAD表示当前版本，HEAD^表示上一个，HEAD~100前一百个 12git reset --hard HEAD^git reset --hard b8a8（根据提交的id回退） 8、 忘记id怎么办，用git reflog记录每一次命令 1git reflog 9、 工作区和暂存区 工作区：我们可以看到的目录 暂存区：.git&#x2F;index 版本库：.git（一般是隐藏的） git add就是把文件从工作区提交到暂存区(stage) git commit就是把文件从暂存区提交到分支(HEAD-&gt;master) 10、查看readme.txt文件工作区和版本库里最新版本的区别 1git diff HEAD -- readme.txt 11、丢弃file文件在工作区的修改 1git checkout -- readme.txt 12、若已经提交到暂存区，那就把暂存区的修改回退到工作区，再清楚工作区的修改 1git reset HEAD readme.txt 13、在工作区删除 1rm test.txt 14、在版本库里删除 1git rm test.txt 15、创建与合并分支 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 16、解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 1git log --graph --pretty=oneline --abbrev-commit 合并禁用fast forward策略，–no-ff参数，表示禁用Fast forward，本次合并要创建一个新的commit，所以加上-m参数， 1git merge --no-ff -m &quot;merge with no-ff&quot; dev 17、多人协作 远程仓库默认名称是master， 首先，多人都从远程库clone，小明创建远程origin的dev分支到本地 1git checkout -b dev origin/dev 小明在本地dev分支上修改然后提交 1git push origin（origin:远程仓库名） dev (dev:本地分支名) 小红也这样推送，发现小明推送在前，有冲突了，于是小红打算git pull最新的提交，在本地合并，解决冲突，再推送：但是git pull失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接， 1$ git branch --set-upstream-to=origin/dev dev Branch ‘dev’ set up to track remote branch ‘dev’ from ‘origin’. 再次 git pull 就成功了，但是合并有冲突，需要手动解决，解决完再commit，再push GitLab的使用 - AIClass公司AIClass网址http://47.94.6.102/ 1、 设置SSH key: http://47.94.6.102/help/ssh/README， 这是保证你能够commit, push的基础。如果没有设置SSH key, 你只能clone，没有办法修改。 1-1、生成秘钥ssh key 1ssh-keygen -t rsa -C [123456789@qq.com] 【出现问题】 书写：ssh -keygen -t rsa -C [&#49;&#50;&#51;&#52;&#x35;&#x36;&#x37;&#x38;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;] 问题：Bad escape character ‘ygen’ 原因：Ssh与-keygen没有空格 改正：ssh-keygen -t rsa -C [&#49;&#x32;&#x33;&#52;&#x35;&#54;&#55;&#x38;&#57;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;] 1-2、获取秘钥 1cat /c/Users/HP-X/.ssh/id_rsa.pub 1-3、粘贴到gitlab 打开设置—SSH—粘贴密钥内容到框内 2、Fork git_practice项目到你的空间里，点击fork即可。 3、git clone到你自己的本地硬盘上，完成之后你的本地硬盘会有下载下来的文件夹。 W 1git clone git@47.94.6.102:AIclass/Week1_PythonFundamentals.git 4、建立新的文件，取名为 test.py , 并在文件里输入 print(“hello world”), 保存并close. 12touch test.pyvim test.py i进入编辑模式 :进入底线命令模式w保存q退出 Linux vi&#x2F;vim | 菜鸟教程 (runoob.com) 1、 利用git diff看一下有什么前后的区别，确认你修改的是正确的。 git diff命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。 $ git diff warning: LF will be replaced by CRLF in test.py. The file will have its original line endings in your working directory diff –git a&#x2F;test.py b&#x2F;test.py index eb7f361…8e467a5 100644 — a&#x2F;test.py +++ b&#x2F;test.py @@ -1 +1,2 @@ -hello,This is a python file.20210816 \\ No newline at end of file +hello,This is a python file.20210816 +hello.Today is 20210817. 2、 使用git add命令把上述新的文件加入进去 1git add test.py 7、利用git status查看最新的情况，确认是否这个文件已经被加进去 $ git status On branch master Your branch is up to date with ‘origin&#x2F;master’. Changes to be committed: (use “git restore –staged …” to unstage) modified: test.py 8、利用git commit -m “your message”， 来commit目前为止的改变，目前为止的所有改动将被记录成历史。 1git commit -m &quot;update_test.py_0817_16:24&quot; 9、利用git push origin master来提交你的改动，这将会把最新改动上传到服务器上。 1git push origin master 10、查看服务器上是否已经有了你的改动，确认即可完成。 11、在本地上，重新打开test.py文件，并在文件中加入一行新的字符串，并保存。 12、重复上述过程，把更新的内容push到服务器端，并检查最后的结果。 Git命令行教程 - AIClass**Git global setup ** （Git配置） 12git config --global user.name &quot;123456789&quot;git config --global user.email &quot;123456789@qq.com&quot; Create a new repository （克隆一个新仓库） 123456git clone git@47.94.6.102:AIclass/Week1_PythonFundamentals.gitcd Week1_PythonFundamentalstouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master Existing folder （在自己目录下创建一个本地仓库，在本地仓库内提取一个远程仓库） 123456cd existing_foldergit initgit remote add origin git@47.94.6.102:AIclass/Week1_PythonFundamentals.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Existing Git repository （已有一个本地仓库了，进入仓库提取远程仓库，和上面基本一样） 1234cd existing_repogit remote add origin git@47.94.6.102:AIclass/Week1_PythonFundamentals.gitgit push -u origin --allgit push -u origin –tags Gitlab fork项目如何同步源项目更新1、查看配置 1git remote -v 2、 添加源项目地址 1git remote add upstream（根名）git@47.94.6.102:AIclass/Week1_PythonFundamentals.git 3、 查看添加源项目地址后的配置 1git remote -v 4、 获取源项目更新 1git fetch upstream 5、 合并原项目更新 1git merge upstream/master Git基本操作总结 【Git 基本操作】 git init ：初始化仓库 git clone ：拷贝一份远程仓库，也就是下载一个项目 【提交与修改】 git add ：添加文件到暂存区 git status ：查看仓库当前状态，显示有变更的文件 git diff ：比较文件的不同，即暂存区和工作区的差异 git commit ：提交暂存区内容到本地仓库 git reset ：回退版本？ git rm ：删除工作区文件 git mv ：移动或重命名工作区文件 【提交日志】 git log ：查看历史提交记录（commit） git blame ：以列表形式查看指定文件的历史修改记录 git log –oneline ：查看历史记录的简洁的版本 git log –reverse –oneline ：逆向显示所有日志 git log –graph ：查看历史中什么时候出现了分支、合并 【远程操作】 git remote ：远程仓库操作 git fetch ：从远处获取代码库 git pull ：下载远程代码并合并 git push ：上传远程代码并合并 【分支管理】 git branch ：列出本地所有分支 git branch （branchname）：创建分支 git branch -b （branchname）：创建分支并立即切换到该分支下 git branch -d （branchname）：删除分支 git checkout （branchname）：切换分支 git merge （name）：合并分支 【合并冲突】 Git 分支管理 | 菜鸟教程 (runoob.com) 【其他命令】 echo ：显示一行代码 touch ：更改时间戳 cat ：串联文件并在标准输出上打印 【添加远程库】 git remote add [ 新的仓库名] [url] 例：git remote add origin2 git@github.com:tianqixin&#x2F;runoob-git-test.git git remote ：查看当前配置有哪些远程仓库 git remote -v ：看到每个别名的实际链接地址 【提取远程仓库】 git fetch：从远程仓库下载新分支与数据。 例：git fetch origin master 从名为origin的远程上拉取名为master的分支到本地分支origin&#x2F;master中 git merge：把远程分支合并到当前你要用的分支。 例：git fetch origin&#x2F;master：合并名为origin&#x2F;master的分支到当前所在分支。 【推送到远程仓库】 git push [alias] [branch] 推送你的新分支与数据到某个远端仓库。将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支。 例：git push origin master：推送本地的master分支到远程origin 【删除远程仓库】 git remote rm [别名] 【删除本地仓库】 1、 git branch：显示所有本地分支 2、 git init 初始化本地版本库 3、 ls -a：找到目录下的.git 4、 rm -rf .git：删除git。此时可以看到master分支已经删除 5、 rm -rf [本地文件夹]：删除本地文件夹 遇到一个好的仓库，如何开始操作 1、fork老师的仓库 2、克隆自己的仓库内容到本地 3、增加老师仓库地址到项目远程分支列表中get remote 3、在本地把内容修改后，上传到自己的仓库 4、老师仓库内容更新后，我get fetch的是什么样的仓库内容？ 【知乎-Git更新fork的项目】 1、clone 自己的 fork 分支到本地，可以直接使用Git 客户端，clone 到本地，如果使用命令行，命令为：$ git clone xxx2、进入仓库，增加源分支地址到你项目远程分支列表中，此处是关键，先得将源仓库指定为 upstream，命令为：$ git remote add upstream xxx 此处可使用git remote -v查看远程分支列表3、fetch 源分支的新版本到本地 $ git fetch upstream4、切换到本地master分支 $ git checkout master5、合并两个版本的代码 $ git merge upstream/master6、将合并后的代码push上去 $ git push origin maste 其他有关Git的信息GitLab仍然要面对本土开源平台的强力竞争，例如阿里云Code、腾讯云开发者平台、百度效率云、华为开源代码托管平台、码云（gitee）、码市等。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-09-08T06:37:56.031Z","updated":"2023-09-12T09:42:22.332Z","comments":false,"path":"2023/09/08/hello-world/","link":"","permalink":"http://example.com/2023/09/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"未分类","slug":"未分类","permalink":"http://example.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"未分类","slug":"未分类","permalink":"http://example.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]}