<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-26T03:55:55.880Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读文章</title>
    <link href="http://example.com/2023/09/26/%E8%AF%BB%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2023/09/26/%E8%AF%BB%E6%96%87%E7%AB%A0/</id>
    <published>2023-09-26T03:47:00.000Z</published>
    <updated>2023-09-26T03:55:55.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI-十人谈"><a href="#对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI-十人谈" class="headerlink" title="对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI 十人谈"></a>对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI 十人谈</h1><p>原创 何思思 <a href="javascript:void(0);">AI科技评论</a> <em>2023-09-22 10:40</em> <em>发表于广东</em></p><p><a href="https://mp.weixin.qq.com/s/0xt-EcuKYo7ceU4tBm3EDg">https://mp.weixin.qq.com/s/0xt-EcuKYo7ceU4tBm3EDg</a></p><blockquote><p>澜码科技于今年2月份在上海成立，与其他创业公司不同的是，澜码科技想做的是基于大模型打造新一代的自动化平台。</p><p>虽然成立时间不长，但澜码科技已于近期完成了数千万人民币的A轮融资，其中IDG资本、联新资本、Atom Capital三家参与了本次投资。</p><p>另外在产品层面，澜码科技已经成功研发出了Agent平台Ask XBot。AI科技评论了解到，其操作主要分为两层，第一层由专家通过传统、新兴的对话交互的方式定义工作流程；第二层由一线员工通过自然语言指令，控制机器协助完成数据分析、资料调取等工作。</p></blockquote><blockquote><p><strong>AI科技评论：选择基于大模型做新一代的自动化平台，是受哪段经历的启发？</strong></p><p><strong>周健：</strong>主要是做RPA给我带来的新视角，现在我做得是人和系统的连接，这样我就能把重复性的劳动问题解决。但不同的是，RPA替代的是一线业务人员重复性的工作，解决的是工作效率问题，我们今天在大语言模型下提供专家知识和经验，解决的是业务流程的质量问题。</p><p>其实我做RPA时，就看到了很多自动化的场景，我知道财务有什么场景，HR有什么场景，国家电网有什么场景，银行有什么场景，保险有什么场景，但由于AI 1.0阶段的AI技术不成熟，成本也非常高，所以很难实现。</p></blockquote><p>RPA？</p><blockquote><p><strong>AI科技评论：澜码现在主要服务哪些客户群体？</strong></p><p><strong>周健：</strong>猎头招聘是主攻场景之一。初级猎头搜候选人主要通过猎聘、脉脉、BOSS直聘等，有3、4年工作经验的猎头可能不需要了，因为他们都会有一个候选人私域库，大概2000人左右，这2000人平均每两、三年要换一次工作，这部分信息的更新是一个很大体量的工作。</p><p>此外，猎头顾问基于私域库寻找候选人的工作方式，对顾问来说准确率高，工作量也小，但是很难把打电话沟通或见面沟通时有价值的数据补充到私域库中，只能在私域库自己去打标签，比如今天和候选人打电话说了啥，当时自己记下来了，但时间一长就忘了，私域库的管理效率和质量都不高。</p><p>大模型出来后，腾讯会议之类的软件有了语音识别的功能，就可以把打电话沟通等交互过程中的“活”数据整理、提炼、存档，这些都是大模型赋予的能力。</p><p>大模型催生了第四个新的范式，可以叫对话式或者匹配式。现在的猎头工作是人岗匹配，抽象来说就是一个X space，x空间和y空间。x空间描述需求，y空间匹配需求。</p><p>大模型出来之后，对话的方式可以提高匹配效率，这是很典型的场景，也在更多其他场景适用，比如房产中介搜房源，设计师搜图，外包程序员搜函数、代码等。</p></blockquote><blockquote><p><strong>AI科技评论：国内外的大模型，都有用过吗？</strong></p><p><strong>周健：</strong>没必要把所有的大模型都用一遍，只需要用目前水平最高的模型就够了。所以我们是在用GPT 4做训练。比如我有10个问题，我会让GPT 4 帮我破解这10个问题，破解完我再让 GPT 4 帮我确认答案、评价答案，然后训练出一个小模型，解决场景问题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI-十人谈&quot;&gt;&lt;a href=&quot;#对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI-十人谈&quot; class=&quot;headerlink&quot; title=&quot;对话澜码周健：大模型不是万能的，也不会弯道超车丨AGI 十人</summary>
      
    
    
    
    <category term="记录" scheme="http://example.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 装饰器</title>
    <link href="http://example.com/2023/09/26/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://example.com/2023/09/26/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2023-09-26T01:28:51.000Z</published>
    <updated>2023-09-26T03:07:17.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-函数装饰器-菜鸟教程"><a href="#Python-函数装饰器-菜鸟教程" class="headerlink" title="Python 函数装饰器 - 菜鸟教程"></a>Python 函数装饰器 - 菜鸟教程</h2><p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p><p>参考：<a href="https://eastlakeside.gitbook.io/interpy-zh/decorators/%EF%BC%88%E4%B8%8E%E6%9C%AC%E6%96%87%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4%EF%BC%89">https://eastlakeside.gitbook.io/interpy-zh/decorators/（与本文完全一致）</a></p><h3 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h3><h3 id="在函数中定义函数"><a href="#在函数中定义函数" class="headerlink" title="在函数中定义函数"></a>在函数中定义函数</h3><h3 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h3><h3 id="将函数作为参数传给另一个函数"><a href="#将函数作为参数传给另一个函数" class="headerlink" title="将函数作为参数传给另一个函数"></a>将函数作为参数传给另一个函数</h3><h3 id="你的第一个装饰器"><a href="#你的第一个装饰器" class="headerlink" title="你的第一个装饰器"></a>你的第一个装饰器</h3><p>装饰器让你在一个函数的前后去执行代码。</p><p>装饰器封装一个函数，并且用这样或者那样的方式来修改它的行为。</p><p> <strong>@</strong> 符号？那只是一个简短的方式来生成一个被装饰的函数。</p><p>使用functools.wraps还原被重写了被装饰函数的名字和注释文档(docstring)</p><p>from functools import wraps</p><p>@wraps(a_func)</p><p><strong>@wraps</strong>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="授权-Authorization"><a href="#授权-Authorization" class="headerlink" title="授权(Authorization)"></a>授权(Authorization)</h4><p>装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。</p><h4 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h4><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><h4 id="在函数中嵌入装饰器"><a href="#在函数中嵌入装饰器" class="headerlink" title="在函数中嵌入装饰器"></a>在函数中嵌入装饰器</h4><h4 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h4><h2 id="装饰器-廖雪峰"><a href="#装饰器-廖雪峰" class="headerlink" title="装饰器 - 廖雪峰"></a>装饰器 - 廖雪峰</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584</a></p><p>现在，假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间<strong>动态增加功能</strong>的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&#x27;call %s():&#x27; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p><code>log()</code>是一个decorator，接受一个函数作为参数，并返回一个函数。</p><p>decorator用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2015-3-25&#x27;)</span><br></pre></td></tr></table></figure><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s():&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><p>这个3层嵌套的decorator用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(&#x27;execute&#x27;)</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2015-3-25&#x27;)</span><br></pre></td></tr></table></figure><p><code>__name__</code>属性变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&#x27;call %s():&#x27; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>或者针对带参数的decorator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s():&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><h2 id="lru-cache-装饰器"><a href="#lru-cache-装饰器" class="headerlink" title="lru_cache 装饰器"></a>lru_cache 装饰器</h2><p><a href="https://juejin.cn/post/6939345971042058248">https://juejin.cn/post/6939345971042058248</a></p><p>这里的lru_cache是什么意思和作用？*args为什么带星号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@lru_cache(maxsize=128)</span><br><span class="line">def get_conf(*args):</span><br><span class="line">    # 建议您复制一个config_private.py放自己的秘密, 如API和代理网址, 避免不小心传github被别人看到</span><br><span class="line">    res = []</span><br><span class="line">    for arg in args:</span><br><span class="line">        r = read_single_conf_with_lru_cache(arg)</span><br><span class="line">        res.append(r)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><p><code>lru_cache</code>是Python标准库中的一个装饰器，用于实现缓存功能。它可以缓存函数的返回值，以便在后续的调用中避免重新计算相同的输入值所对应的结果。这有助于提高函数的执行效率，特别是在需要计算代价较高的操作时。</p><p>具体来说：</p><ul><li><code>lru_cache</code>是Least Recently Used（LRU，最近最少使用）缓存的缩写，它会保留最近调用的函数的结果，并在缓存达到指定大小（由<code>maxsize</code>参数指定）时，自动淘汰最不常使用的结果，以保持缓存的大小。</li><li><code>maxsize</code>参数指定缓存的最大大小，即最多保存多少个不同输入值的结果。如果没有指定<code>maxsize</code>，则缓存的大小会无限增长。</li><li>当函数被装饰为<code>@lru_cache(maxsize=128)</code>时，函数的每个不同的参数组合（传递给<code>*args</code>的值）都会被缓存，以及它们对应的返回值。下次再次使用相同的参数调用函数时，如果参数组合已经在缓存中，函数不会再次执行，而是直接返回之前的结果。</li><li>这里的<code>*args</code>是Python中的可变参数，它允许函数接受任意数量的位置参数。在<code>get_conf</code>函数中，<code>*args</code>表示接受任意数量的参数，这些参数将被传递到<code>read_single_conf_with_lru_cache</code>函数中。<code>*</code>用于解包参数，因为<code>args</code>是一个元组，<code>*args</code>会将元组中的每个元素作为单独的参数传递给函数。</li></ul><p>总结：<code>@lru_cache</code>用于缓存函数的计算结果，<code>*args</code>用于接受任意数量的输入参数，并将它们传递给被装饰的函数。这可以提高函数的执行效率，特别是在需要多次调用相同参数的情况下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python-函数装饰器-菜鸟教程&quot;&gt;&lt;a href=&quot;#Python-函数装饰器-菜鸟教程&quot; class=&quot;headerlink&quot; title=&quot;Python 函数装饰器 - 菜鸟教程&quot;&gt;&lt;/a&gt;Python 函数装饰器 - 菜鸟教程&lt;/h2&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <link href="http://example.com/2023/09/25/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/09/25/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-09-25T09:46:34.000Z</published>
    <updated>2023-09-26T01:48:01.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个基于 Node.js 的静态网站生成器，它帮助用户快速构建和部署博客和其他类型的静态网站。Hexo 的主要特点包括简单易用、高度可配置、支持主题和插件，以及快速的构建和部署过程。下面是一些关于 Hexo 的基本信息和用法：</p><h2 id="主要功能和特点："><a href="#主要功能和特点：" class="headerlink" title="主要功能和特点："></a>主要功能和特点：</h2><ol><li><strong>Markdown 支持：</strong> Hexo 使用 Markdown 作为默认的内容格式，这使得撰写和发布文章变得非常简单。</li><li><strong>快速构建：</strong> Hexo生成静态网页，所以页面加载速度很快，因为不需要在每个页面访问时进行数据库查询。</li><li><strong>主题支持：</strong> Hexo支持自定义主题，用户可以选择或创建适合自己的主题来美化网站。</li><li><strong>插件扩展：</strong> Hexo提供了许多插件，可以用来扩展其功能，如添加社交分享按钮、SEO优化、代码高亮等。</li><li><strong>部署选项：</strong> Hexo支持多种部署选项，包括部署到GitHub Pages、Netlify、Vercel、FTP服务器等。</li></ol><h2 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h2><ol><li><p><strong>安装 Hexo：</strong> 首先，您需要在计算机上安装 Node.js 和 Git。然后使用以下命令安装 Hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化博客：</strong> 使用以下命令在您的计算机上创建一个新的Hexo博客：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">hexo init myblog</span><br><span class="line">cd myblog</span><br></pre></td></tr></table></figure></li><li><p><strong>撰写文章：</strong> 使用Markdown格式编写文章，可以使用Hexo提供的命令来创建新文章：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>这将在<code>source/_posts</code>目录下创建一个Markdown文件，您可以在其中编写文章内容。</p></li><li><p><strong>生成静态文件：</strong> 使用以下命令生成静态文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">hexo generate (或简写为 hexo g)</span><br></pre></td></tr></table></figure><p>这将生成静态网页到<code>public</code>文件夹中。</p></li><li><p><strong>本地预览：</strong> 使用以下命令在本地预览您的网站：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">hexo server (或简写为 hexo s)</span><br></pre></td></tr></table></figure><p>您可以在浏览器中访问<code>http://localhost:4000</code>来查看您的博客。</p></li><li><p><strong>部署博客：</strong> 最后，您可以使用Hexo的部署命令将博客发布到您选择的托管平台或服务器上。根据您的部署选择，命令会有所不同。</p></li></ol><h1 id="一些也用Hexo搭建的个人博客网站"><a href="#一些也用Hexo搭建的个人博客网站" class="headerlink" title="一些也用Hexo搭建的个人博客网站"></a>一些也用Hexo搭建的个人博客网站</h1><p><a href="https://hwame.top/categories/Hexo/">https://hwame.top/categories/Hexo/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;Hexo 是一个基于 Node.js 的静态网站生成器，它帮助用户快速构建和部署博客和其他类型的静态网站。Hexo 的主要特</summary>
      
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Git相关操作</title>
    <link href="http://example.com/2023/09/11/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2023/09/11/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2023-09-11T08:58:15.000Z</published>
    <updated>2023-09-26T01:48:14.040Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h1 id="Git配置（git-config）"><a href="#Git配置（git-config）" class="headerlink" title="Git配置（git config）"></a>Git配置（git config）</h1><p>Git 提供了一个叫做<code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。</p><blockquote><p>这些变量可以存放在以下三个不同的地方：</p><p><code>· /etc/gitconfig 文件</code>：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</p><p><code>· ~/.gitconfig 文件</code>：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</p><p><code>· 工作目录中的 .git/config 文件（当前项目的 Git 目录中的配置文件）</code>：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git&#x2F;config 里的配置会覆盖 &#x2F;etc&#x2F;gitconfig 中的同名变量。</p></blockquote><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><h1 id="Git基础操作步骤"><a href="#Git基础操作步骤" class="headerlink" title="Git基础操作步骤"></a>Git基础操作步骤</h1><p>1、 找一个自己想放东西的目录，作为仓库。初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>2、 配置个人信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;liuliuliu&quot;</span><br><span class="line">git config --global user.email [123456789@qq.com]</span><br></pre></td></tr></table></figure><p>2-1、查看user信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=liuliuliu`</span><br><span class="line">`user.email=123456789@qq.com</span><br></pre></td></tr></table></figure></blockquote><p>2-2、查看某个环境变量的设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>2-3、查看所有配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>2-4、删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>3、 查看隐藏的.git目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ah</span><br></pre></td></tr></table></figure><p>4、 查看当前仓库状态，有没有什么是改动的、改动未提交的、全部提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>5、 查看文件的改动情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>6、 查看历史记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git log --pretty=oneline(显示成一行)</span><br></pre></td></tr></table></figure><p>7、 回退到上一个提交的版本，HEAD表示当前版本，HEAD^表示上一个，HEAD~100前一百个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard b8a8（根据提交的id回退）</span><br></pre></td></tr></table></figure><p>8、 忘记id怎么办，用git reflog记录每一次命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>9、 工作区和暂存区</p><img src="/2023/09/11/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA.png" class="" title="工作区和暂存区"><blockquote><p>工作区：我们可以看到的目录</p><p>暂存区：.git&#x2F;index</p><p>版本库：.git（一般是隐藏的）</p></blockquote><blockquote><p><code>git add</code>就是把文件从工作区提交到暂存区(stage)</p><p><code>git commit</code>就是把文件从暂存区提交到分支(HEAD-&gt;master)</p></blockquote><p>10、查看readme.txt文件工作区和版本库里最新版本的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure><p>11、丢弃file文件在工作区的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>12、若已经提交到暂存区，那就把暂存区的修改回退到工作区，再清楚工作区的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p>13、在工作区删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test.txt</span><br></pre></td></tr></table></figure><p>14、在版本库里删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br></pre></td></tr></table></figure><p>15、创建与合并分支</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>16、解决冲突</p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>合并禁用fast forward策略，–no-ff参数，表示禁用Fast forward，本次合并要创建一个新的commit，所以加上-m参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>17、多人协作</p><p>远程仓库默认名称是master，</p><p>首先，多人都从远程库clone，小明创建远程origin的dev分支到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>小明在本地dev分支上修改然后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin（origin:远程仓库名） dev (dev:本地分支名)</span><br></pre></td></tr></table></figure><p>小红也这样推送，发现小明推送在前，有冲突了，于是小红打算<code>git pull</code>最新的提交，在本地合并，解决冲突，再推送：但是git pull失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><p>Branch ‘dev’ set up to track remote branch ‘dev’ from ‘origin’.</p><p>再次 <code>git pull</code> 就成功了，但是合并有冲突，需要手动解决，解决完再commit，再push</p><h1 id="GitLab的使用-AIClass"><a href="#GitLab的使用-AIClass" class="headerlink" title="GitLab的使用 - AIClass"></a>GitLab的使用 - AIClass</h1><p>公司AIClass网址<a href="http://47.94.6.102/">http://47.94.6.102/</a></p><p>1、 设置SSH key: <a href="http://47.94.6.102/help/ssh/README%EF%BC%8C">http://47.94.6.102/help/ssh/README，</a> 这是保证你能够commit, push的基础。如果没有设置SSH key, 你只能clone，没有办法修改。</p><p>1-1、生成秘钥ssh key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C [123456789@qq.com]</span><br></pre></td></tr></table></figure><p>【出现问题】</p><p>书写：ssh -keygen -t rsa -C [<a href="mailto:&#49;&#50;&#51;&#52;&#x35;&#x36;&#x37;&#x38;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#49;&#50;&#51;&#52;&#x35;&#x36;&#x37;&#x38;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;</a>]</p><p>问题：Bad escape character ‘ygen’</p><p>原因：Ssh与-keygen没有空格</p><p>改正：ssh-keygen -t rsa -C [<a href="mailto:&#49;&#x32;&#x33;&#52;&#x35;&#54;&#55;&#x38;&#57;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;">&#49;&#x32;&#x33;&#52;&#x35;&#54;&#55;&#x38;&#57;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;</a>]</p><p>1-2、获取秘钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /c/Users/HP-X/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>1-3、粘贴到gitlab</p><p>打开设置—SSH—粘贴密钥内容到框内</p><p>2、Fork git_practice项目到你的空间里，点击fork即可。</p><p>3、git clone到你自己的本地硬盘上，完成之后你的本地硬盘会有下载下来的文件夹。 W</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@47.94.6.102:AIclass/Week1_PythonFundamentals.git</span><br></pre></td></tr></table></figure><p>4、建立新的文件，取名为 <a href="http://test.py/">test.py</a> , 并在文件里输入 print(“hello world”), 保存并close.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.py</span><br><span class="line">vim test.py</span><br></pre></td></tr></table></figure><p>i进入编辑模式</p><p>:进入底线命令模式w保存q退出</p><p><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi&#x2F;vim | 菜鸟教程 (runoob.com)</a></p><p>1、 利用git diff看一下有什么前后的区别，确认你修改的是正确的。</p><p>git diff命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。</p><p>$ <code>git diff</code></p><p>warning: LF will be replaced by CRLF in <a href="http://test.py/">test.py</a>.</p><p>The file will have its original line endings in your working directory</p><p><strong>diff –git a&#x2F;test.py b&#x2F;test.py</strong></p><p><strong>index eb7f361…8e467a5 100644</strong></p><p><strong>— a&#x2F;test.py</strong></p><p><strong>+++ b&#x2F;test.py</strong></p><p>@@ -1 +1,2 @@</p><p>-hello,This is a python file.20210816</p><p>\ No newline at end of file</p><p>+hello,This is a python file.20210816</p><p>+hello.Today is 20210817.</p><p>2、 使用git add命令把上述新的文件加入进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.py</span><br></pre></td></tr></table></figure><p>7、利用git status查看最新的情况，确认是否这个文件已经被加进去</p><p>$ <code>git status</code></p><p>On branch master</p><p>Your branch is up to date with ‘origin&#x2F;master’.</p><p>Changes to be committed:</p><p>(use “git restore –staged …” to unstage)</p><p> modified: <a href="http://test.py/">test.py</a></p><p>8、利用git commit -m “your message”， 来commit目前为止的改变，目前为止的所有改动将被记录成历史。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;update_test.py_0817_16:24&quot;</span><br></pre></td></tr></table></figure><p>9、利用git push origin master来提交你的改动，这将会把最新改动上传到服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>10、查看服务器上是否已经有了你的改动，确认即可完成。</p><p>11、在本地上，重新打开test.py文件，并在文件中加入一行新的字符串，并保存。</p><p>12、重复上述过程，把更新的内容push到服务器端，并检查最后的结果。</p><h1 id="Git命令行教程-AIClass"><a href="#Git命令行教程-AIClass" class="headerlink" title="Git命令行教程 - AIClass"></a>Git命令行教程 - AIClass</h1><p>**Git global setup ** <strong>（Git配置）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;123456789&quot;</span><br><span class="line">git config --global user.email &quot;123456789@qq.com&quot;</span><br></pre></td></tr></table></figure><p><strong>Create a new repository</strong> <strong>（克隆一个新仓库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@47.94.6.102:AIclass/Week1_PythonFundamentals.git</span><br><span class="line">cd Week1_PythonFundamentals</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>Existing folder</strong> <strong>（在自己目录下创建一个本地仓库，在本地仓库内提取一个远程仓库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@47.94.6.102:AIclass/Week1_PythonFundamentals.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>Existing Git repository</strong> <strong>（已有一个本地仓库了，进入仓库提取远程仓库，和上面基本一样）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote add origin git@47.94.6.102:AIclass/Week1_PythonFundamentals.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin –tags</span><br></pre></td></tr></table></figure><h1 id="Gitlab-fork项目如何同步源项目更新"><a href="#Gitlab-fork项目如何同步源项目更新" class="headerlink" title="Gitlab fork项目如何同步源项目更新"></a>Gitlab fork项目如何同步源项目更新</h1><p>1、查看配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>2、 添加源项目地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream（根名）git@47.94.6.102:AIclass/Week1_PythonFundamentals.git</span><br></pre></td></tr></table></figure><p>3、 查看添加源项目地址后的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>4、 获取源项目更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure><p>5、 合并原项目更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><h1 id="Git基本操作总结"><a href="#Git基本操作总结" class="headerlink" title="Git基本操作总结"></a>Git基本操作总结</h1><img src="/2023/09/11/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" class="" title="image-20211213204157225"><p><strong>【Git 基本操作】</strong></p><blockquote><p><strong>git init</strong> <strong>：初始化仓库</strong></p><p><strong>git clone</strong> <strong>：拷贝一份远程仓库，也就是下载一个项目</strong></p></blockquote><p><strong>【提交与修改】</strong></p><blockquote><p><strong>git add</strong> <strong>：添加文件到暂存区</strong></p><p><strong>git status</strong> <strong>：查看仓库当前状态，显示有变更的文件</strong></p><p><strong>git diff</strong> <strong>：比较文件的不同，即暂存区和工作区的差异</strong></p><p><strong>git commit</strong> <strong>：提交暂存区内容到本地仓库</strong></p><p><strong>git reset</strong> <strong>：回退版本？</strong></p><p><strong>git rm</strong> <strong>：删除工作区文件</strong></p><p><strong>git mv</strong> <strong>：移动或重命名工作区文件</strong></p></blockquote><p><strong>【提交日志】</strong></p><blockquote><p><strong>git log</strong> <strong>：查看历史提交记录（commit）</strong></p><p><strong>git blame</strong> <strong>：以列表形式查看指定文件的历史修改记录</strong></p><p><strong>git log –oneline</strong> <strong>：查看历史记录的简洁的版本</strong></p><p><strong>git log –reverse –oneline</strong> <strong>：逆向显示所有日志</strong></p><p><strong>git log –graph</strong> <strong>：查看历史中什么时候出现了分支、合并</strong></p></blockquote><p><strong>【远程操作】</strong></p><blockquote><p><strong>git remote</strong> <strong>：远程仓库操作</strong></p><p><strong>git fetch</strong> <strong>：从远处获取代码库</strong></p><p><strong>git pull</strong> <strong>：下载远程代码并合并</strong></p><p><strong>git push</strong> <strong>：上传远程代码并合并</strong></p></blockquote><p><strong>【分支管理】</strong></p><blockquote><p><strong>git branch</strong> <strong>：列出本地所有分支</strong></p><p><strong>git branch</strong> <strong>（branchname）：创建分支</strong></p><p><strong>git branch -b</strong> <strong>（branchname）：创建分支并立即切换到该分支下</strong></p><p><strong>git branch -d</strong> <strong>（branchname）：删除分支</strong></p><p><strong>git checkout</strong> <strong>（branchname）：切换分支</strong></p><p><strong>git merge</strong> <strong>（name）：合并分支</strong></p></blockquote><p><strong>【合并冲突】</strong></p><p><a href="https://www.runoob.com/git/git-branch.html">Git 分支管理 | 菜鸟教程 (runoob.com)</a></p><p><strong>【其他命令】</strong></p><blockquote><p><strong>echo</strong> <strong>：显示一行代码</strong></p><p><strong>touch</strong> <strong>：更改时间戳</strong></p><p><strong>cat</strong> <strong>：串联文件并在标准输出上打印</strong></p></blockquote><p><strong>【添加远程库】</strong></p><blockquote><p><strong>git remote add [</strong> <strong>新的仓库名] [url]</strong></p><p>例：git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin&#x2F;runoob-git-test.git</p><p><strong>git remote</strong> <strong>：查看当前配置有哪些远程仓库</strong></p><p><strong>git remote -v</strong> <strong>：看到每个别名的实际链接地址</strong></p></blockquote><p><strong>【提取远程仓库】</strong></p><blockquote><p><strong>git fetch：从远程仓库下载新分支与数据。</strong></p><p>例：git fetch origin master 从名为origin的远程上拉取名为master的分支到本地分支origin&#x2F;master中</p><p><strong>git merge：把远程分支合并到当前你要用的分支。</strong></p><p>例：git fetch origin&#x2F;master：合并名为origin&#x2F;master的分支到当前所在分支。</p></blockquote><p><strong>【推送到远程仓库】</strong></p><blockquote><p><strong>git push [alias] [branch] 推送你的新分支与数据到某个远端仓库。将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支。</strong></p><p>例：git push origin master：推送本地的master分支到远程origin</p></blockquote><p><strong>【删除远程仓库】</strong></p><blockquote><p><strong>git remote rm [别名]</strong></p></blockquote><p><strong>【删除本地仓库】</strong></p><blockquote><p><strong>1、</strong> <strong>git branch：显示所有本地分支</strong></p><p><strong>2、</strong> <strong>git init</strong> <strong>初始化本地版本库</strong></p><p><strong>3、</strong> <strong>ls -a：找到目录下的.git</strong></p><p><strong>4、</strong> <strong>rm -rf .git：删除git。此时可以看到master分支已经删除</strong></p><p><strong>5、</strong> <strong>rm -rf [本地文件夹]：删除本地文件夹</strong></p></blockquote><h1 id="遇到一个好的仓库，如何开始操作"><a href="#遇到一个好的仓库，如何开始操作" class="headerlink" title="遇到一个好的仓库，如何开始操作"></a>遇到一个好的仓库，如何开始操作</h1><blockquote><p>1、fork老师的仓库</p><p>2、克隆自己的仓库内容到本地</p><p>3、增加老师仓库地址到项目远程分支列表中get remote</p><p>3、在本地把内容修改后，上传到自己的仓库</p><p>4、老师仓库内容更新后，我get fetch的是什么样的仓库内容？</p></blockquote><p>【知乎-Git更新fork的项目】</p><p>1、clone 自己的 fork 分支到本地，可以直接使用Git 客户端，clone 到本地，如果使用命令行，命令为：<code>$ git clone xxx</code><br>2、进入仓库，增加源分支地址到你项目远程分支列表中，此处是关键，先得将源仓库指定为 upstream，命令为：<code>$ git remote add upstream xxx</code> 此处可使用git remote -v查看远程分支列表<br>3、fetch 源分支的新版本到本地 <code>$ git fetch upstream</code><br>4、切换到本地master分支 <code>$ git checkout master</code><br>5、合并两个版本的代码 <code>$ git merge upstream/master</code><br>6、将合并后的代码push上去 <code>$ git push origin maste</code></p><h1 id="其他有关Git的信息"><a href="#其他有关Git的信息" class="headerlink" title="其他有关Git的信息"></a>其他有关Git的信息</h1><p>GitLab仍然要面对本土开源平台的强力竞争，例如阿里云Code、腾讯云开发者平台、百度效率云、华为开源代码托管平台、码云（gitee）、码市等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/p&gt;
&lt;p&gt;Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;Git 与常用的版本控制工具 CVS, Subver</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/09/08/hello-world/"/>
    <id>http://example.com/2023/09/08/hello-world/</id>
    <published>2023-09-08T06:37:56.031Z</published>
    <updated>2023-09-12T09:42:22.332Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="未分类" scheme="http://example.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
